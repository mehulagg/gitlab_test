# frozen_string_literal: true

require 'spec_helper'

describe Gitlab::BackgroundMigration::MigrateVulnerabilityOccurrencesToVulnerabilities, :migration, schema: 20200228111111 do
  include TraceHelpers

  let!(:user) { create(:user) }
  let!(:project) { create(:project) }

  let(:scanner) do
    create(:vulnerabilities_scanner, project: project)
  end

  let(:identifiers) do
    [
      create(:vulnerabilities_identifier),
      create(:vulnerabilities_identifier)
    ]
  end

  before do
  end

  context 'vulnerability_occurrence exists for latest security report' do
    context 'has no associated vulnerability' do
      let!(:pipeline) { create(:ci_pipeline, project: project, status: 'success', user: user) }
      let!(:vulnerability_occurrence) { create(:vulnerabilities_occurrence, project: project, pipelines: [pipeline]) }

      it 'creates a new vulnerability' do
        expect(Vulnerability.all.count).to eq(0)
        expect(Vulnerabilities::Occurrence.all.count).to eq(1)
        expect(Vulnerabilities::OccurrencePipeline.all.count).to eq(1)
        described_class.new.perform(project.id)
        expect(Vulnerability.all.count).to eq(1)
      end

      context 'has been dismissed' do
        let!(:dismiss_feedback) do
          create(:vulnerability_feedback, :sast, :dismissal,
                 project: project, project_fingerprint: vulnerability_occurrence.project_fingerprint)
        end

        it 'new vulnerability should have state of dismissed' do
          expect(Vulnerability.all.count).to eq(0)
          expect(Vulnerabilities::Occurrence.all.count).to eq(1)
          expect(Vulnerabilities::OccurrencePipeline.all.count).to eq(1)
          described_class.new.perform(project.id)
          expect(Vulnerability.all.count).to eq(1)
          expect(Vulnerability.last.state).to eq('dismissed')
        end
      end
    end

    context 'has an associated vulnerability' do
      let!(:vulnerability) { create(:vulnerability, project: project) }
      let!(:pipeline) { create(:ci_pipeline, project: project, status: 'success', user: user) }
      let!(:vulnerability_occurrence) { create(:vulnerabilities_occurrence, project: project, pipelines: [pipeline], vulnerability: vulnerability) }

      it 'does not create a new vulnerability' do
        expect(Vulnerability.all.count).to eq(1)
        described_class.new.perform(project.id)
        expect(Vulnerability.all.count).to eq(1)
      end

      context 'has been dismissed' do
        let!(:dismiss_feedback) do
          create(:vulnerability_feedback, :sast, :dismissal,
                 project: project, project_fingerprint: vulnerability_occurrence.project_fingerprint)
        end

        it 'vulnerability should now have state of dismissed' do
          expect(Vulnerability.last.state).to eq('detected')
          described_class.new.perform(project.id)
          expect(Vulnerability.last.state).to eq('dismissed')
        end
      end
    end
  end

  context 'vulnerability_occurrence exists for previous security report' do
    let!(:vulnerability) { create(:vulnerability, project: project) }
    let!(:pipeline1) { create(:ci_pipeline, project: project, status: 'success', user: user) }
    let!(:pipeline2) { create(:ci_pipeline, project: project, status: 'success', user: user) }
    let!(:vulnerability_occurrence) { create(:vulnerabilities_occurrence, project: project, pipelines: [pipeline1], vulnerability: vulnerability) }

    it 'does not create a new vulnerability' do
      expect(Vulnerability.all.count).to eq(1)
      vulnerability_occurrence.pipelines << pipeline2
      described_class.new.perform(project.id)
      expect(Vulnerability.all.count).to eq(1)
    end
  end
end
