import { shallowMount } from '@vue/test-utils';
import axios from '~/lib/utils/axios_utils';
import createFlash from '~/flash';
import MockAdapter from 'axios-mock-adapter';
import App from 'ee/vulnerability_management/components/app.vue';
import waitForPromises from 'helpers/wait_for_promises';
import VulnerabilityStateDropdown from 'ee/vulnerability_management/components/vulnerability_state_dropdown.vue';

const mockAxios = new MockAdapter(axios);
jest.mock('~/flash');

describe('Vulnerability management app', () => {
  let wrapper;

  beforeEach(() => {
    wrapper = shallowMount(App, {
      propsData: {
        id: 1,
        state: 'doesnt matter',
      },
    });
  });

  afterEach(() => {
    wrapper.destroy();
    mockAxios.reset();
    createFlash.mockReset();
  });

  it('the vulnerability state dropdown is rendered', () => {
    expect(wrapper.find(VulnerabilityStateDropdown).exists()).toBe(true);
  });

  it('when the vulnerability state dropdown emits a change event, a POST API call is made', () => {
    const dropdown = wrapper.find(VulnerabilityStateDropdown);
    mockAxios.onPost().reply(201);

    dropdown.vm.$emit('change');

    return waitForPromises().then(() => {
      expect(mockAxios.history.post).toHaveLength(1); // Check that a POST request was made.
    });
  });

  it('when the vulnerability state changes but the API call fails, an error message is displayed', () => {
    const dropdown = wrapper.find(VulnerabilityStateDropdown);
    mockAxios.onPost().reply(400);

    dropdown.vm.$emit('change');

    return waitForPromises().then(() => {
      expect(mockAxios.history.post).toHaveLength(1);
      expect(createFlash).toHaveBeenCalledTimes(1);
    });
  });
});
