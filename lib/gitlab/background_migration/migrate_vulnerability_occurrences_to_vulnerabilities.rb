# frozen_string_literal: true

module Gitlab
  module BackgroundMigration
    # This migration creates vulnerabilities records for vulnerability_occurrences records
    # that exist on the latest successful pipeline of the default branch of a given project
    # and do not already have a vulnerabilities record created.
    # It also updates the states of vulnerabilities records to dismissed if the corresponding
    # vulnerability_occurrences record was dismissed.
    class MigrateVulnerabilityOccurrencesToVulnerabilities
      delegate :select_all, :execute, :quote_string, to: :connection

      def perform(project_id)
        sql = <<-SQL
          SELECT vulnerability_occurrences.id
          FROM vulnerability_occurrences
          INNER JOIN vulnerability_occurrence_pipelines ON vulnerability_occurrence_pipelines.occurrence_id = vulnerability_occurrences.id
          INNER JOIN ci_pipelines ON ci_pipelines.id = vulnerability_occurrence_pipelines.pipeline_id
          WHERE ci_pipelines.id IN (
            SELECT max(id) as id
            FROM ci_pipelines
            WHERE ci_pipelines.project_id = #{project_id}
              AND (
                EXISTS (
                  SELECT 1
                  FROM vulnerability_occurrence_pipelines
                  WHERE (ci_pipelines.id=vulnerability_occurrence_pipelines.pipeline_id)
                )
              )
              AND (ci_pipelines.status IN ('success'))
            GROUP BY ci_pipelines.project_id
          )
        SQL
        result = ActiveRecord::Base.connection.execute(sql)
        vulnerability_occurrence_ids = result.values.flatten
        vulnerability_occurrence_ids.each do |vulnerability_occurrence_id|
          create_vulnerability_record(vulnerability_occurrence_id)
        end

        update_vulnerability_to_dismissed(project_id)
      end

      private

      def create_vulnerability_record(vulnerability_occurrence_id)
        insert_vulnerability_sql = <<-SQL
          INSERT INTO vulnerabilities(project_id, author_id, created_at, updated_at, title, title_html, state, severity, confidence, report_type)
          SELECT vulnerability_occurrences.project_id, ci_pipelines.user_id, vulnerability_occurrences.created_at, vulnerability_occurrences.updated_at, vulnerability_occurrences.name, vulnerability_occurrences.name, #{Vulnerability.states["detected"]}, vulnerability_occurrences.severity, vulnerability_occurrences.confidence, vulnerability_occurrences.report_type
          FROM vulnerability_occurrences
          INNER JOIN ci_pipelines on ci_pipelines.id =
            (SELECT max(id) AS id
              FROM ci_pipelines
              WHERE ci_pipelines.project_id = vulnerability_occurrences.project_id
                AND vulnerability_occurrences.id = #{vulnerability_occurrence_id}
                AND (
                  EXISTS (SELECT 1 FROM vulnerability_occurrence_pipelines
                    WHERE (ci_pipelines.id=vulnerability_occurrence_pipelines.pipeline_id)
                  )
                )
                AND ci_pipelines.status IN ('success')
              GROUP BY ci_pipelines.project_id
            )
          WHERE vulnerability_occurrences.vulnerability_id is null
            AND vulnerability_occurrences.id = #{vulnerability_occurrence_id}
          RETURNING id;
        SQL

        insert_vulnerability_result = execute(insert_vulnerability_sql)
        vulnerability_id = insert_vulnerability_result.values&.first&.first

        if vulnerability_id
          update_vulnerability_occurrences_sql = "UPDATE vulnerability_occurrences SET vulnerability_id = #{vulnerability_id} WHERE id = #{vulnerability_occurrence_id} ;"
          execute(update_vulnerability_occurrences_sql)
        end
      rescue => e
        puts "errored out for vulnerability_occurrence_id #{vulnerability_occurrence_id}"
        puts e.message
      end

      def update_vulnerability_to_dismissed(project_id)
        update_vulnerability_to_dismissed_sql = <<-SQL
          UPDATE vulnerabilities
          SET state = #{Vulnerability.states["dismissed"]}
          FROM vulnerability_occurrences
          WHERE vulnerability_occurrences.vulnerability_id = vulnerabilities.id
            AND vulnerabilities.state = #{Vulnerability.states["detected"]}
            AND (
              EXISTS (
                SELECT 1
                FROM vulnerability_feedback
                WHERE vulnerability_occurrences.report_type = vulnerability_feedback.category
                  AND vulnerability_occurrences.project_id = vulnerability_feedback.project_id
                  AND ENCODE(vulnerability_occurrences.project_fingerprint, 'HEX') = vulnerability_feedback.project_fingerprint
                  AND vulnerability_feedback.feedback_type = #{::Vulnerabilities::Feedback.feedback_types["dismissal"]}
              )
            )
            AND vulnerability_occurrences.project_id = #{project_id};
        SQL
        execute(update_vulnerability_to_dismissed_sql)
      rescue => e
        puts "errored out for project_id #{project_id}"
        puts e.message
      end

      def connection
        @connection ||= ActiveRecord::Base.connection
      end
    end
  end
end
